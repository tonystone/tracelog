///
///  TextFormat+EncodingTests.swift
///
///  Copyright 2018 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 12/31/18.
///
import XCTest

import TraceLog
%{
    asciiVariants = [
        ("ascii",             "Non-Lossy", "Simple Ascii text."),
        ("iso2022JP",         "Non-Lossy", "Simple Ascii text."),
        ("isoLatin1",         "Non-Lossy", "Simple Ascii text."),
        ("isoLatin2",         "Non-Lossy", "Simple Ascii text."),
        ("japaneseEUC",       "Non-Lossy", "Simple Ascii text."),
        ("macOSRoman",        "Non-Lossy", "Simple Ascii text."),
        ("nextstep",          "Non-Lossy", "Simple Ascii text."),
        ("nonLossyASCII",     "Non-Lossy", "Simple Ascii text."),
        ("shiftJIS",          "Non-Lossy", "Simple Ascii text."),
        ("symbol",            "Lossy",     "?????? ????? ????."),
        ("unicode",           "Non-Lossy", "Simple Ascii text."),
        ("utf16",             "Non-Lossy", "Simple Ascii text."),
        ("utf16BigEndian",    "Non-Lossy", "Simple Ascii text."),
        ("utf16LittleEndian", "Non-Lossy", "Simple Ascii text."),
        ("utf32",             "Non-Lossy", "Simple Ascii text."),
        ("utf32BigEndian",    "Non-Lossy", "Simple Ascii text."),
        ("utf32LittleEndian", "Non-Lossy", "Simple Ascii text."),
        ("utf8",              "Non-Lossy", "Simple Ascii text."),
        ("windowsCP1250",     "Non-Lossy", "Simple Ascii text."),
        ("windowsCP1251",     "Non-Lossy", "Simple Ascii text."),
        ("windowsCP1252",     "Non-Lossy", "Simple Ascii text."),
        ("windowsCP1253",     "Non-Lossy", "Simple Ascii text."),
        ("windowsCP1254",     "Non-Lossy", "Simple Ascii text."),
    ]

    unicodeVariants = [
        ("ascii",             "Lossy",     "Print a few unicode characters ?, ?, ??, ?, ?, ?."),
        ("iso2022JP",         "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("isoLatin1",         "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("isoLatin2",         "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("japaneseEUC",       "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("macOSRoman",        "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("nextstep",          "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("nonLossyASCII",     "Non-Lossy", "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("shiftJIS",          "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("symbol",            "Lossy",     "????? ? ??? ??????? ?????????? ?, ??, ????, ??, ??, ??."),
        ("unicode",           "Non-Lossy", "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("utf16",             "Non-Lossy", "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("utf16BigEndian",    "Non-Lossy", "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("utf16LittleEndian", "Non-Lossy", "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("utf32",             "Non-Lossy", "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("utf32BigEndian",    "Non-Lossy", "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("utf32LittleEndian", "Non-Lossy", "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("utf8",              "Lossy",     "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª."),
        ("windowsCP1250",     "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("windowsCP1251",     "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("windowsCP1252",     "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("windowsCP1253",     "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
        ("windowsCP1254",     "Lossy",     "Print a few unicode characters ?, ??, ????, ??, ??, ??."),
    ]
}%

/// TextFormat Encoding Tests.
///
class TextFormatEncodingWithUnicodeTests: XCTestCase {
% for (Encoding, Lossiness, Expected) in asciiVariants:

    /// Test that we can encode a simple Ascii message to `String.Encoding.${Encoding}`.
    ///
    /// Note: This will be a "${Lossiness.upper()}" operation when using just Ascii characters in the messages.
    ///
    func test${Encoding.title()}EncodingWithSimpleAsciiMessage() {
        let format = TextFormat(template: "%{message}", encoding: .${Encoding}, terminator: "")

        guard let bytes = format.bytes(from: 28800.0, level: .info, tag: "TestTag", message: "Simple Ascii text.", runtimeContext: TestRuntimeContext(processName: "TestProcess", processIdentifier: 100, threadIdentifier: 1100), staticContext: TestStaticContext())
            else { XCTFail("Failed to convert log entry to encoding \".${Encoding}\""); return }

        XCTAssertEqual(String(bytes: bytes, encoding: .${Encoding}), "${Expected}",
            "Failed conversion to \".${Encoding}\".")
    }
% end

% for (Encoding, Lossiness, Expected) in unicodeVariants:

    /// Test that we can encode a Unicode message to `String.Encoding.${Encoding}`.
    ///
    /// Note: This will be a "${Lossiness.upper()}" operation when using Unicode characters in the messages.
    ///
    func test${Encoding.title()}EncodingWithUnicodeMessage() {
        let format = TextFormat(template: "%{message}", encoding: .${Encoding}, terminator: "")

        guard let bytes = format.bytes(from: 28800.0, level: .info, tag: "TestTag", message: "Print a few unicode characters â™¡, ğŸŒ, ğŸ‡µğŸ‡·, ğŸŒ, ğŸ§, ğŸª.", runtimeContext: TestRuntimeContext(processName: "TestProcess", processIdentifier: 100, threadIdentifier: 1100), staticContext: TestStaticContext())
            else { XCTFail("Failed to convert log entry to encoding \".${Encoding}\""); return }

        XCTAssertEqual(String(bytes: bytes, encoding: .${Encoding}), "${Expected}",
            "Failed conversion to \".${Encoding}\".")
    }
% end
}
